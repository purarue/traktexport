#!/usr/bin/env python3

"""
A CLI script to add/remove items from history using the trakt url

this is very unstable, it is super basic right now
"""

# TODO:
# - allow setting limit for unwatch, or an offset?

import json
from typing import (
    Literal,
    Optional,
    NamedTuple,
    Union,
    Iterator,
    Iterable,
    Any,
)
from datetime import datetime, timezone

import click
from logzero import logger  # type: ignore[import]
from traktexport.export import _check_config

from trakt.movies import Movie  # type: ignore[import]
from trakt.tv import TVShow, TVEpisode  # type: ignore[import]
from trakt.sync import search  # type: ignore[import]

_check_config()

USERNAME: Optional[str] = None


@click.group()
@click.option(
    "-u",
    "--username",
    help="Trakt username",
    required=True,
    envvar="TRAKT_USERNAME",
    show_envvar=True,
)
def main(username: str) -> None:
    global USERNAME

    USERNAME = username


class MovieId(NamedTuple):
    id: str

    def trakt(self) -> Movie:
        from trakt.movies import Movie

        mv = Movie(self.id, year=None, slug=self.id)
        mv._get()
        return mv


class EpisodeId(NamedTuple):
    id: str
    season: int
    episode: int

    def trakt(self) -> TVEpisode:
        from trakt.tv import TVEpisode

        ep = TVEpisode(show=self.id, season=self.season, number=self.episode)
        ep._get()
        return ep


class TVShowId(NamedTuple):
    id: str

    def trakt(self) -> TVShow:
        from trakt.tv import TVShow

        tv = TVShow(self.id)
        tv._get()
        return tv


Input = Union[MovieId, EpisodeId, TVShowId]


def _print_response_pretty(d: Any) -> bool:
    if not isinstance(d, dict):
        return False
    try:
        if "added" in d or "deleted" in d:
            key = "added" if "added" in d else "deleted"
            if d[key]["movies"] or d[key]["episodes"]:
                click.secho(f"{key.capitalize()} count:", bold=True, fg="green")
                if d[key]["movies"]:
                    click.echo(f"Movies: {d[key]['movies']}")
                if d[key]["episodes"]:
                    click.echo(f"Episodes: {d[key]['episodes']}")
        else:
            return False

        not_found_lines = []
        for k, v in d["not_found"].items():
            # return false so whole error gets printed
            if not isinstance(v, list):
                return False
            for item in v:
                not_found_lines.append(f"{k}: {repr(item)}")

        if not_found_lines:
            click.secho("Not found:", bold=True, fg="red")
            for line in not_found_lines:
                click.echo(line)

        click.echo()
        return True
    except Exception:
        # if failed to access any of the keys, skip nice print
        return False


def _print_response(d: Any) -> None:
    if _print_response_pretty(d):
        return
    if isinstance(d, dict):
        click.echo(json.dumps(d, indent=2), err=True)
    else:
        click.echo(d, err=True)


def _parse_url_to_input(url: str) -> Input:
    from urllib.parse import urlsplit

    parts = urlsplit(url)
    if parts.netloc != "trakt.tv":
        raise ValueError(f"Invalid URL netloc: {parts.netloc}, expected trakt.tv")

    prts = [u.strip() for u in parts.path.split("/") if u.strip()]

    match prts:
        case ["movies", id, *_]:
            return MovieId(id)
        case ["shows", id, "seasons", season, "episodes", episode, *_]:
            return EpisodeId(id, int(season), int(episode))
        case ["shows", id, *_]:
            return TVShowId(id)
        case _:
            raise ValueError(f"Invalid URL parts: {prts}")


def _mark_watched(input: Input, watched_at: Optional[datetime] = None) -> None:
    if isinstance(input, MovieId):
        mv = input.trakt()
        _print_response(mv.mark_as_seen(watched_at=watched_at))
        if click.confirm("Set rating?", default=True):
            rating = click.prompt("Rating", type=int)
            _print_response(mv.rate(rating))
    elif isinstance(input, EpisodeId):
        ep = input.trakt()
        _print_response(ep.mark_as_seen(watched_at=watched_at))
    elif isinstance(input, TVShowId):
        raise NotImplementedError(
            "TVShow not implemented, this would probably mean watch an entire show?"
        )
    else:
        raise ValueError(f"Invalid input type: {type(input)}")


def _parse_datetime(
    ctx: click.Context, param: click.Argument, value: Optional[str]
) -> Union[datetime, None, Literal["released"]]:
    import dateparser
    import warnings

    # remove pytz warning from dateparser module
    warnings.filterwarnings("ignore", "The localize method is no longer necessary")

    if value is None:
        return None

    ds = value.strip()
    if ds == "released":
        return "released"
    dt = dateparser.parse(ds)
    if dt is None:
        raise click.BadParameter(f"Could not parse '{ds}' into a date")
    else:
        ts = dt.timestamp()
        local_dt = datetime.fromtimestamp(ts)
        click.echo(f"Date: {local_dt}", err=True)
        return datetime.fromtimestamp(ts, tz=timezone.utc)


def _display_search_entry(entry: Any, *, include_slug: bool = False) -> str:
    buf: str = ""
    if isinstance(entry, Movie):
        buf += f"Movie:\t{entry.title} ({entry.year})"
    elif isinstance(entry, TVEpisode):
        buf += f"Episode:\t{entry.show} S{entry.season}E{entry.episode} - {entry.title}"
    elif isinstance(entry, TVShow):
        buf += f"Show:\t{entry.title}"
    else:
        raise ValueError(f"Invalid entry type: {type(entry)}")

    if include_slug:
        buf += f" | {entry.ext}"

    return buf


def _search_trakt() -> Optional[Input]:
    # prompt user to ask if they want to search for a
    # particular type of media, else just search for all
    # types
    click.echo(
        "What type of media do you want to search for?\n[M]ovie, [S]how, [E]pisode, [U]rl, [A]ll: ",
        nl=False,
    )
    pressed = click.getchar().upper()
    click.echo()
    # 'movie', 'show', 'episode', or 'person'
    pressed = pressed if pressed in ["M", "S", "E", "A", "U"] else "A"
    if pressed == "U":
        return None
    media_type: Optional[str] = {
        "M": "movie",
        "S": "show",
        "E": "episode",
        "A": None,
    }.get(pressed)

    search_term = click.prompt("Search for", type=str)
    results = search(search_term, search_type=media_type)  # type: ignore[arg-type]

    if not results:
        raise click.ClickException("No results found")

    choice: Optional[int] = None

    while choice is None:
        click.echo("Results:")
        for i, result in enumerate(results, 1):
            click.echo(f"{i}: {_display_search_entry(result, include_slug=True)}")

        choice = click.prompt("Pick result", type=int, default=1)
        assert choice is not None
        if choice < 1 or choice > len(results):
            raise click.ClickException("Invalid choice")

    result = results[choice - 1]
    result._get()
    return _parse_url_to_input(f"https://trakt.tv/{result.ext}")


def _handle_input(url: Optional[str]) -> Input:
    inp: Optional[Input] = None
    if url is not None:
        inp = _parse_url_to_input(url)
    else:
        inp = _search_trakt()
        if inp is None:
            urlp = click.prompt("Url", type=str)
            inp = _parse_url_to_input(urlp)
    assert inp is not None
    return inp


@main.command(short_help="mark movie/episode as watched")
@click.option("--url", help="URL to watch", required=False, default=None)
@click.option(
    "-a",
    "--at",
    help="Watched at time (date like string, or 'released')",
    callback=_parse_datetime,
    default=None,
)
def watch(url: Optional[str], at: Optional[datetime]) -> None:
    """
    Pass the movie/episode url to mark it as watched right now
    """
    _mark_watched(_handle_input(url), at)
    _print_recent_history(_recent_history_entries(limit=10))


from traktexport.dal import _parse_history, HistoryEntry


def _recent_history_entries(
    *, limit: int = 10, page: int = 1
) -> Iterator[HistoryEntry]:
    from traktexport.export import _trakt_request

    username = USERNAME
    assert username is not None

    data = _trakt_request(
        f"users/{username}/history?page={page}&limit={limit}", logger=None, sleep_time=0
    )

    yield from _parse_history(data)


def _display_history_entry(entry: HistoryEntry, include_id: bool = False) -> str:
    from traktexport.dal import Movie, Episode

    watched_at = entry.watched_at.astimezone().strftime("%Y-%m-%d %H:%M:%S")
    s: str
    if isinstance(entry.media_data, Movie):
        s = f"{watched_at} {entry.media_data.title}"
    elif isinstance(entry.media_data, Episode):
        ep = entry.media_data
        assert isinstance(ep, Episode)
        s = f"{watched_at} {ep.show.title} S{ep.season}E{ep.episode} - {ep.title}"
    else:
        raise ValueError(f"Invalid media_type: {entry.media_type}")

    if include_id:
        s += f" ({entry.history_id})"
    return s


def _print_recent_history(
    history: Iterable[HistoryEntry], include_id: bool = False
) -> None:
    history = list(history)  # consume so the request happens
    click.secho("Recent history:", bold=True)
    for i, entry in enumerate(history, 1):
        click.echo(f"{i}: {_display_history_entry(entry, include_id=include_id)}")


@main.command(short_help="remove recent watched item")
@click.option("-i/-a", "--interactive/--non-interactive", default=True, is_flag=True)
@click.option("--yes", "-y", is_flag=True, default=False, help="Skip confirmation")
def unwatch(interactive: bool, yes: bool) -> None:
    """
    Remove the last watched item from your history
    """
    from traktexport.export import _trakt_request

    data = list(_recent_history_entries(limit=10))
    picked: HistoryEntry = data[0]
    if interactive:
        _print_recent_history(data, include_id=True)
        picked_int: int = click.prompt(
            "Pick item (number) to remove",
            type=int,
            default=1,
        )
        if picked_int < 1 or picked_int > len(data):
            raise click.ClickException("Invalid choice")

        picked = data[picked_int - 1]

    click.echo(f"Removing {_display_history_entry(picked, include_id=True)}...")

    last_history_id = picked.history_id
    if not yes:
        click.confirm("Remove from history?", abort=True, default=True)

    click.echo(f"Removing {last_history_id}...")

    resp = _trakt_request(
        "sync/history/remove",
        method="post",
        data={"movies": [], "episodes": [], "ids": [last_history_id]},
        logger=logger,
        sleep_time=0,
    )

    _print_response(resp)
    _print_recent_history(_recent_history_entries(limit=10), include_id=True)


@main.command(short_help="show recent history")
@click.argument("limit", type=click.IntRange(min=1, max=100), default=10)
def recent(limit: int) -> None:
    """
    Show recent history
    """
    _print_recent_history(_recent_history_entries(limit=limit))


def _rate_movie(input: Input, rating: int) -> None:
    if isinstance(input, MovieId):
        mv = input.trakt()
        _print_response(mv.rate(rating))
    elif isinstance(input, EpisodeId):
        ep = input.trakt()
        _print_response(ep.rate(rating))
    elif isinstance(input, TVShowId):
        tv = input.trakt()
        _print_response(tv.rate(rating))
    else:
        raise ValueError(f"Invalid input type: {type(input)}")


@main.command(short_help="rate movie/tv show/episode")
@click.option("--url", help="URL to rate", default=None)
@click.option(
    "-r",
    "--rating",
    help="Rating (1-10)",
    type=click.IntRange(min=1, max=10),
    required=True,
    prompt=True,
)
def rate(url: Optional[str], rating: int) -> None:
    """
    Pass the movie/TV show/episode url to rate it
    """
    _rate_movie(_handle_input(url), rating)


if __name__ == "__main__":
    main()
